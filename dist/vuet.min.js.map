{"version":3,"file":"vuet.min.js","sources":["../src/util.js","../src/vuet-static.js","../src/debug.js","../src/rules/life.js","../src/rules/need.js","../src/rules/once.js","../src/vuet.js","../src/index.js","../src/rules/index.js"],"sourcesContent":["const util = {\n  isObject (obj) {\n    return !!obj && Object.prototype.toString.call(obj) === '[object Object]'\n  },\n  getArgMerge () {\n    let opt = {}\n    const args = arguments\n    if (typeof args[0] === 'string') {\n      opt[args[0]] = args.length > 1 ? args[1] : args[0]\n    } else if (args[0] && util.isObject(args[0])) {\n      opt = args[0]\n    }\n    return opt\n  },\n  isPromise (obj) {\n    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n  }\n}\n\nexport default util\n","import debug from './debug'\nimport util from './util'\n\nexport let _Vue\n\nexport default function (Vuet) {\n  Object.assign(Vuet, {\n    installed: false,\n    options: {\n      rules: {}\n    },\n    install (Vue) {\n      if (this.installed) return this\n      this.installed = true\n      _Vue = Vue\n      Object.defineProperty(Vue.prototype, '$vuet', {\n        get () { return this.$root._vuet }\n      })\n      Vue.mixin({\n        beforeCreate () {\n          if (typeof this.$options.vuet !== 'undefined') {\n            if (this.$options.vuet instanceof Vuet) {\n              this._vuet = this.$options.vuet\n              this._vuet._init(this)\n            }\n          }\n        },\n        destroyed () {\n          if (typeof this.$options.vuet !== 'undefined') {\n            if (this.$options.vuet instanceof Vuet) {\n              this._vuet.destroy(this)\n            }\n          }\n        }\n      })\n      return this\n    },\n    mapModules (opts) {\n      const mixins = Object.keys(opts).map(alias => {\n        const path = opts[alias]\n        return {\n          computed: {\n            [alias]: {\n              get () {\n                debug.assertModule(this.$vuet, path)\n                return this.$vuet.modules[path].state\n              },\n              set (val) {\n                debug.assertModule(this.$vuet, path)\n                this.$vuet.modules[path].state = val\n              }\n            },\n            [`$${alias}`]: {\n              get () {\n                debug.assertModule(this.$vuet, path)\n                return this.$vuet.modules[path]\n              },\n              set () {\n                debug.error('It is read-only')\n              }\n            }\n          }\n        }\n      })\n      return {\n        mixins\n      }\n    },\n    mapRules () {\n      const opts = util.getArgMerge.apply(null, arguments)\n      const vueRules = []\n      const addRule = (ruleName, any) => {\n        const rules = Vuet.options.rules[ruleName]\n        if (typeof any === 'string') {\n          vueRules.push(rules.rule({ path: any }))\n        } else {\n          vueRules.push(rules.rule(any))\n        }\n      }\n      Object.keys(opts).forEach(ruleName => {\n        const any = opts[ruleName]\n        if (Array.isArray(any)) {\n          return any.forEach(item => {\n            addRule(ruleName, item)\n          })\n        }\n        addRule(ruleName, any)\n      })\n      return {\n        mixins: vueRules\n      }\n    },\n    rule () {\n      Vuet.options.rules[arguments[0]] = arguments[1]\n      if (typeof arguments[1].install === 'function') {\n        arguments[1].install(Vuet)\n      }\n      return this\n    },\n    callRuleHook (hook, vuet) {\n      Object.keys(Vuet.options.rules).forEach(k => {\n        if (typeof Vuet.options.rules[k][hook] === 'function') {\n          Vuet.options.rules[k][hook](vuet)\n        }\n      })\n    }\n  })\n}\n","import { _Vue } from './vuet-static'\n\nexport default {\n  error (msg) {\n    throw new Error(`[vuet] ${msg}`)\n  },\n  warn (msg) {\n    if (process.env.NODE_ENV !== 'production') {\n      typeof console !== 'undefined' && console.warn(`[vuet] ${msg}`)\n    }\n  },\n  assertModule (vuet, name) {\n    if (name in vuet.modules) {\n      return\n    }\n    this.error(`The '${name}' module does not exist`)\n  },\n  assertVue () {\n    if (!_Vue) {\n      this.error('must call Vue.use(Vuet) before creating a store instance')\n    }\n  },\n  assertPromise () {\n    if (typeof Promise === 'undefined') {\n      this.error('Vuet requires a Promise polyfill in this browser')\n    }\n  }\n}\n","import debug from '../debug'\n\nexport default {\n  rule ({ path }) {\n    return {\n      beforeCreate () {\n        debug.assertModule(this.$vuet, path)\n        this.$vuet.getModule(path).fetch()\n      },\n      destroyed () {\n        this.$vuet.getModule(path).reset()\n      }\n    }\n  }\n}\n","import debug from '../debug'\n\nexport default {\n  rule ({ path }) {\n    return {\n      beforeCreate () {\n        debug.assertModule(this.$vuet, path)\n        this.$vuet.getModule(path).fetch()\n      }\n    }\n  }\n}\n","import debug from '../debug'\nimport util from '../util'\n\nexport default {\n  init (vuet) {\n    vuet.__once__ = {}\n  },\n  rule ({ path }) {\n    return {\n      beforeCreate () {\n        debug.assertModule(this.$vuet, path)\n        if (this.$vuet.__once__[path]) return\n        const back = this.$vuet.getModule(path).fetch()\n        if (util.isPromise(back)) {\n          return back.then(res => {\n            this.$vuet.__once__[path] = true\n          })\n        }\n        this.$vuet.__once__[path] = true\n      }\n    }\n  }\n}\n","import debug from './debug'\nimport util from './util'\nimport { _Vue } from './vuet-static'\nexport default class Vuet {\n  constructor (opts) {\n    debug.assertVue()\n    debug.assertPromise()\n\n    this.modules = {}\n    this.store = {}\n    this.options = {\n      pathJoin: '/',\n      modules: {}\n    }\n    this.app = null\n    this.vm = new _Vue({\n      data: {\n        modules: this.store\n      }\n    })\n    Object.assign(this.options, opts)\n    const initModule = (paths, modules) => {\n      Object.keys(modules).forEach(path => {\n        const newNames = [...paths, path]\n        const newName = newNames.join(this.options.pathJoin)\n        if (!util.isObject(modules[path])) return\n        if (typeof modules[path].data === 'function') {\n          this.register(newName, modules[path])\n        }\n        Object.keys(modules[path]).forEach(chlidName => {\n          if (util.isObject(modules[path][chlidName])) {\n            initModule(newNames, modules[path])\n          }\n        })\n      })\n    }\n    initModule([], this.options.modules)\n    Vuet.callRuleHook('init', this)\n  }\n  _init (app) {\n    this.app = app\n  }\n  register (path, opts) {\n    const vuet = this\n    _Vue.set(vuet.store, path, opts.data())\n    Object.defineProperty(opts, 'state', {\n      get () {\n        return vuet.store[path]\n      },\n      set (val) {\n        vuet.store[path] = val\n      }\n    })\n    Object.assign(opts, {\n      reset () {\n        this.state = this.data()\n      }\n    })\n    Object.keys(opts).forEach(k => {\n      if (typeof opts[k] === 'function') {\n        const native = opts[k]\n        opts[k] = function proxy () {\n          return native.apply(vuet.modules[path], arguments)\n        }\n      }\n    })\n    if (util.isObject(opts.state)) {\n      Object.keys(opts.state).forEach(k => {\n        Object.defineProperty(opts, k, {\n          get () {\n            return vuet.store[path][k]\n          },\n          set (val) {\n            vuet.store[path][k] = val\n          }\n        })\n      })\n    }\n    vuet.modules[path] = opts\n    return this\n  }\n  getModule (path) {\n    return this.modules[path]\n  }\n  getState (path) {\n    return this.modules[path].state\n  }\n  destroy () {\n    this.vm.$destroy()\n    Vuet.callRuleHook('destroy', this)\n  }\n}\n","import rules from './rules/index'\nimport VuetStatic from './vuet-static'\nimport Vuet from './vuet'\n\nVuetStatic(Vuet)\nrules(Vuet)\nexport const mapRules = Vuet.mapRules.bind(Vuet)\nexport const mapModules = Vuet.mapModules.bind(Vuet)\n\nexport default Vuet\n","import life from './life'\nimport need from './need'\nimport once from './once'\n\nexport default function install (Vuet) {\n  Vuet\n    .rule('life', life)\n    .rule('need', need)\n    .rule('once', once)\n}\n"],"names":["util","obj","Object","prototype","toString","call","opt","args","arguments","length","isObject","then","_Vue","msg","Error","vuet","name","modules","error","Promise","path","assertModule","this","$vuet","getModule","fetch","reset","__once__","back","isPromise","Vuet","opts","assertVue","assertPromise","store","options","app","vm","assign","initModule","paths","keys","forEach","newNames","newName","join","_this","pathJoin","data","register","chlidName","callRuleHook","set","defineProperty","val","state","k","native","apply","$destroy","Vue","installed","$root","_vuet","mixin","$options","_init","destroy","map","alias","getArgMerge","vueRules","addRule","ruleName","any","rules","push","rule","Array","isArray","item","install","hook","life","need","once","mapRules","bind","mapModules"],"mappings":"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"}